package Child
import TerrainUtils
import Entity
import initlater Snowball
import Snowbomb
import Rollingball
import KillStreaks
import initlater Snowman
import Iceshard
import LinkedList
import ItemHandling
import TimedBar
import MapBounds
import PhysicsModule
import TimerUtils
import IceWall
import Assets

public LinkedList<Child> humChildren = new LinkedList<Child>()
public LinkedList<Child> orcChildren = new LinkedList<Child>()

public constant real SX1 = -2400.
public constant real SY1 = 4100
public constant real SX2 = 2220
public constant real SY2 = 4100

public function getEnemyChildren(player owner) returns LinkedList<Child>
	if owner.getId() > 5
		return humChildren
	return orcChildren

public class Child extends UnitEntity
	use PhysicsModule
	trigger t
	boolean fixPos = false
	TimedBar wrapBar
	SnowmanDummy snowman
	
	construct( vec3 pos, player owner, int id)
		super(pos, 50., CreateUnit(owner, id, pos.x, pos.y, 0))
		if owner.getId() > 5
			orcChildren.add(this)
		else
			humChildren.add(this)
		restitution = .25
		friction = 0.80
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_EFFECT, () -> onCast())
		EventListener.add(actor, EVENT_PLAYER_UNIT_DEATH, () -> onDeath())

	function removeItemAndCheck(int itemid, int spellid)
		for int i = 0 to 5
			var uit = UnitItemInSlot(actor, i)
			if GetItemTypeId(uit) == itemid
				if GetItemCharges(uit) <= 1
					RemoveItem(uit)
					if not UnitHasItemOfTypeBJ(actor, itemid)
						actor.removeAbility(spellid)
				else
					SetItemCharges(uit,GetItemCharges(uit) -1)
				break

	function onCast()
		var id = GetSpellAbilityId()
		var target = vec2(GetSpellTargetX(), GetSpellTargetY()).withTerrainZ()
		let castPos = pos.add(0,0,78)
		let angle = pos.angleTo2d(target)
		switch id
			case 'A000'
				new Snowball(castPos, owner, angle )
			case 'A001'
				new Snowbomb(castPos, owner, target)
				removeItemAndCheck('I006', 'A001')
			case 'A002'
				new Rollingball(pos.polarProject(16, angle, (90).asAngleDegrees()).add(0,0,16), owner, angle )
				removeItemAndCheck('I004', 'A002')
			case 'A003'
				new SnowmanMissile(pos.add(0,0,16), owner, target.toVec2())
				removeItemAndCheck('I005', 'A003')
			case 'A004'
				new IceMissile(pos.add(0,0,32), owner, target)
				removeItemAndCheck('I003', 'A004')
			case 'A008'
				new Iceshard(pos.add(0,0,24), owner, angle )
				removeItemAndCheck('I00E', 'A008')
		
	function onDeath()
		var p = GetKillingUnit().getOwner()
		var p2 = GetDyingUnit().getOwner()
		var chld = GetDyingUnit().getUserData()castTo Child
		if chld.wrapBar != null
			chld.wrapBar.terminate()
		adjustKills(p, p2)
		timer t = getTimer()
		t..setData(GetDyingUnit().getUserData())..start(7., function Child.revive)
		removeallspell(chld.actor)
				
	static function revive()
		var t = GetExpiredTimer()
		Child c = t.getData() castTo Child
		
		if c.owner.getId() > 5
			ReviveHero(c.actor, SX2 + 64 * c.owner.getId(), SY2, false)
			c.setPos(vec3(SX2 + 64 * c.owner.getId(), SY2, 530.))
		else
			ReviveHero(c.actor, SX1 + 64 * c.owner.getId(), SY1, false)
			c.setPos(vec3(SX1 + 64 * c.owner.getId(), SY1, 530.))
		c.setVel(vec3(0,0,0))
		c.actor.setVertexColor(255,255,255,255)
		SetUnitPropWindow(c.actor,60)
		t.release()	
		if GetLocalPlayer() == c.owner
			PanCameraToTimed(c.actor.getX(), c.actor.getY(), 1.)
			ClearSelection()
			SelectUnit(c.actor, true)

	override function update()
		super.update()
		physicsUpdate(this)
		if not pos.toVec2().inBounds()
			pos = vec3(0,3600,200)
			vel = vec3(0,0,0)
			actor.setPos(pos.toVec2())
		pos += vel
		if fixPos
			actor.setPos(pos.toVec2())
			fixPos = false
		else
			setXY(pos)

	override function onEscapeGround()
		actor.setPropWindow(0)

	override function onGroundHit()
		actor.setPropWindow(60)
		
	override function onGround()
		if vel.lengthSquared() > 6.
			if not isTerrainWalkable(pos.x, pos.y)
				vel += getBounceVec(vel.toVec2(),getPathingNormal(pos.toVec2())).withZ(0)
				fixPos = true
		
public function getPathingNormal(vec2 pos) returns vec2
	int numberOfTests = 12
	real radius = 64
	vec2 addedVecs = vec2(0, 0)
	for int i = 1 to numberOfTests
		vec2 direction = vec2(0,0).polarOffset((i*2*bj_PI/numberOfTests).asAngleRadians(), radius)
		vec2 testPoint = pos + direction
		if isTerrainWalkable(testPoint.x, testPoint.y)
			addedVecs += direction
	return addedVecs.setLength(1.) * (-1.)
	
public function getBounceVec(vec2 vel2, vec2 nor2) returns vec2
		vec3 vel3 = vel2.toVec3()
		vec3 nor3 = nor2.toVec3()
		vec3 pv3 = vel3.project(nor3)
		vec2 pv2 = pv3.toVec2()
		pv2 *= (-1.4)
		return pv2

		
		