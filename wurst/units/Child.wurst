package Child
import initlater Snowball
import Snowbomb
import Rollingball
import KillStreaks
import initlater Snowman
import Iceshard
import ItemHandling
import TimedBar
import PhysicsEntity
import IceWall
import ClosureTimers
import Assets
import Collision

public constant humChildren = new LinkedList<Child>()
public constant orcChildren = new LinkedList<Child>()

public constant LEFT_SPAWN = vec2(-2400, 4100)
public constant RIGHT_SPAWN = vec2(2020, 4100)

public function getEnemyChildren(player owner) returns LinkedList<Child>
	if owner.getId() > 4
		return humChildren
	return orcChildren

public class Child extends UnitEntity
	use PhysicsModule
	trigger t
	boolean fixPos = false
	TimedBar wrapBar
	SnowmanDummy snowman

	construct(vec3 pos, player owner, int id)
		super(createUnit(owner, id, pos, 0 .fromDeg()), pos, 50.)
		if owner.getId() > 4
			orcChildren.add(this)
		else
			humChildren.add(this)
		restitution = .25
		surfaceFriction = 0.80
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_EFFECT, () -> onCast())
		EventListener.add(actor, EVENT_PLAYER_UNIT_DEATH, () -> onDeath())
		addSpawnShield()
		registerCollidable(this, (e) -> skip)

	function removeItemAndCheck(int itemid, int spellid)
		for int i = 0 to 5
			var uit = UnitItemInSlot(actor, i)
			if GetItemTypeId(uit) == itemid
				if GetItemCharges(uit) <= 1
					RemoveItem(uit)
					if not UnitHasItemOfTypeBJ(actor, itemid)
						actor.removeAbility(spellid)
				else
					SetItemCharges(uit,GetItemCharges(uit) -1)
				break

	function onCast()
		var id = GetSpellAbilityId()
		var target = vec2(GetSpellTargetX(), GetSpellTargetY()).withTerrainZ()
		let castPos = getPos().add(0,0,78)
		let angle = pos.angleTo2d(target)
		switch id
			case 'A000'
				new Snowball(castPos, owner, angle, target)
			case 'A001'
				new Snowbomb(castPos, owner, target)
				removeItemAndCheck('I006', 'A001')
			case 'A002'
				new Rollingball(pos.polarProject(16, angle, (90).asAngleDegrees()).add(0,0,16), owner, angle )
				removeItemAndCheck('I004', 'A002')
			case 'A003'
				new SnowmanMissile(pos.add(0,0,16), owner, target.toVec2())
				removeItemAndCheck('I005', 'A003')
			case 'A004'
				new IceMissile(pos.add(0,0,32), owner, target)
				removeItemAndCheck('I003', 'A004')
			case 'A008'
				new Iceshard(pos.add(0,0,24), owner, angle )
				removeItemAndCheck('I00E', 'A008')

	function onDeath()
		var p = GetKillingUnit().getOwner()
		var p2 = GetDyingUnit().getOwner()
		if wrapBar != null
			wrapBar.terminate()
		adjustKills(p, p2)
		removeallspell(actor)

		doAfter(7.) ->
			if owner.getId() > 4
				actor.revive(RIGHT_SPAWN, false)
				setPos(RIGHT_SPAWN.withTerrainZ() + vec3(48. * owner.getId() - 6, 0, 530.))
			else
				actor.revive(LEFT_SPAWN, false)
				setPos(LEFT_SPAWN.withTerrainZ() + vec3(48. * owner.getId(), 0, 530.))

			addSpawnShield()
			setVel(vec3(0,0,0))
			actor..setVertexColor(255,255,255,255)
			..setPropWindow(60 .fromDeg())
			owner..clearSelection()
			..panCamToTimed(actor, 1.)
			..select(actor)

	override function update()
		physicsUpdate(this)
		super.update()
		if not pos.toVec2().inBounds()
			pos = vec3(0,3600,200)
			vel = vec3(0,0,0)
			actor.setPos(pos.toVec2())


	override function onEscapeGround()
		print("leave")
		actor.setPropWindow(0 .fromDeg())

	override function onGroundHit()
		print("hit")
		actor.setPropWindow(60 .fromDeg())

	function addSpawnShield()
		actor.addAbility(AbilityIds.invulnerable)
		let eff = actor.addEffect(Abilities.divineShieldTarget, "chest")
		doAfter(5.) ->
			actor.removeAbility(AbilityIds.invulnerable)
			eff.destr()

	ondestroy
		removeCollidable(this)

public function getPathingNormal(vec2 pos) returns vec2
	int numberOfTests = 8
	let radius = 64.
	vec2 addedVecs = vec2(0, 0)
	for int i = 1 to numberOfTests
		vec2 direction = vec2(0,0).polarOffset((i*2*bj_PI/numberOfTests).asAngleRadians(), radius)
		vec2 testPoint = pos + direction
		if testPoint.isTerrainWalkable()
			addedVecs += direction
	return addedVecs.setLength(1.) * (-1.)

public function getBounceVec(vec2 vel2, vec2 nor2) returns vec2
		vec3 vel3 = vel2.toVec3()
		vec3 nor3 = nor2.toVec3()
		vec3 pv3 = vel3.project(nor3)
		vec2 pv2 = pv3.toVec2()
		pv2 *= (-1.9)
		return pv2


// boolean first = true
// init
// 	EventListener.add(EVENT_PLAYER_END_CINEMATIC) ->
// 		if first
// 			for i = 0 to 20
// 				let child = new Child(vec3(-800, 3500, 20), Player(0), 'hfoo')
// 				child.setVel(vec3(-10. -i, -10. + i, 2))
// 				doAfter(15) ->
// 					child.terminate()
// 			// first = false
// 		else
