package Child
import initlater Snowball
import Snowbomb
import Rollingball
import KillStreaks
import initlater Snowman
import Iceshard
import ItemHandling
import TimedBar
import PhysicsEntity
import IceWall
import ClosureTimers
import AbilityIds
import Assets

public LinkedList<Child> humChildren = new LinkedList<Child>()
public LinkedList<Child> orcChildren = new LinkedList<Child>()

public constant real SX1 = -2400.
public constant real SY1 = 4100
public constant real SX2 = 2220
public constant real SY2 = 4100

public function getEnemyChildren(player owner) returns LinkedList<Child>
	if owner.getId() > 5
		return humChildren
	return orcChildren

public class Child extends UnitEntity
	use PhysicsModule
	trigger t
	boolean fixPos = false
	TimedBar wrapBar
	SnowmanDummy snowman
	
	construct( vec3 pos, player owner, int id)
		super(createUnit(owner, id, pos, 0 .fromDeg()), pos, 50.)
		if owner.getId() > 5
			orcChildren.add(this)
		else
			humChildren.add(this)
		restitution = .25
		surfaceFriction = 0.80
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_EFFECT, () -> onCast())
		EventListener.add(actor, EVENT_PLAYER_UNIT_DEATH, () -> onDeath())

	function removeItemAndCheck(int itemid, int spellid)
		for int i = 0 to 5
			var uit = UnitItemInSlot(actor, i)
			if GetItemTypeId(uit) == itemid
				if GetItemCharges(uit) <= 1
					RemoveItem(uit)
					if not UnitHasItemOfTypeBJ(actor, itemid)
						actor.removeAbility(spellid)
				else
					SetItemCharges(uit,GetItemCharges(uit) -1)
				break

	function onCast()
		var id = GetSpellAbilityId()
		var target = vec2(GetSpellTargetX(), GetSpellTargetY()).withTerrainZ()
		let castPos = getPos().add(0,0,78)
		let angle = pos.angleTo2d(target)
		switch id
			case 'A000'
				new Snowball(castPos, owner, angle, target)
			case 'A001'
				new Snowbomb(castPos, owner, target)
				removeItemAndCheck('I006', 'A001')
			case 'A002'
				new Rollingball(pos.polarProject(16, angle, (90).asAngleDegrees()).add(0,0,16), owner, angle )
				removeItemAndCheck('I004', 'A002')
			case 'A003'
				new SnowmanMissile(pos.add(0,0,16), owner, target.toVec2())
				removeItemAndCheck('I005', 'A003')
			case 'A004'
				new IceMissile(pos.add(0,0,32), owner, target)
				removeItemAndCheck('I003', 'A004')
			case 'A008'
				new Iceshard(pos.add(0,0,24), owner, angle )
				removeItemAndCheck('I00E', 'A008')
		
	function onDeath()
		var p = GetKillingUnit().getOwner()
		var p2 = GetDyingUnit().getOwner()
		var chld = GetDyingUnit().getUserData()castTo Child
		if chld.wrapBar != null
			chld.wrapBar.terminate()
		adjustKills(p, p2)
		timer t = getTimer()
		t..setData(GetDyingUnit().getUserData())..start(7., function Child.revive)
		removeallspell(chld.actor)
				
	static function revive()
		var t = GetExpiredTimer()
		Child c = t.getData() castTo Child
		
		if c.owner.getId() > 5
			ReviveHero(c.actor, SX2 + 64 * c.owner.getId(), SY2, false)
			c.setPos(vec3(SX2 + 64 * c.owner.getId(), SY2, 530.))
		else
			ReviveHero(c.actor, SX1 + 64 * c.owner.getId(), SY1, false)
			c.setPos(vec3(SX1 + 64 * c.owner.getId(), SY1, 530.))

		c.actor.addAbility(AbilityIds.invulnerable)
		let eff = c.actor.addEffect(Abilities.divineShieldTarget, "chest")
		doAfter(5.) ->
			c.actor.removeAbility(AbilityIds.invulnerable)
			eff.destr()
		c.setVel(vec3(0,0,0))
		c.actor.setVertexColor(255,255,255,255)
		SetUnitPropWindow(c.actor,60)
		t.release()	
		if GetLocalPlayer() == c.owner
			PanCameraToTimed(c.actor.getX(), c.actor.getY(), 1.)
			ClearSelection()
			SelectUnit(c.actor, true)

	override function update()
		physicsUpdate(this)
		super.update()
		if not pos.toVec2().inBounds()
			pos = vec3(0,3600,200)
			vel = vec3(0,0,0)
			actor.setPos(pos.toVec2())

	override function onEscapeGround()
		actor.setPropWindow(0 .fromDeg())

	override function onGroundHit()
		actor.setPropWindow(60 .fromDeg())
		
	override function onGround(Entity e)
		if e.flying
			e.flying = false
			onGroundHit()
		// e.scaleVel(surfaceFriction)
		if vel.lengthSquared() > 6.
			let nextPos = pos + vel
			if not nextPos.toVec2().isTerrainWalkable()
				vel += getBounceVec(vel.toVec2(), getPathingNormal(nextPos.toVec2())).withZ(0)
				fixPos = true
		
public function getPathingNormal(vec2 pos) returns vec2
	int numberOfTests = 8
	let radius = 64.
	vec2 addedVecs = vec2(0, 0)
	for int i = 1 to numberOfTests
		vec2 direction = vec2(0,0).polarOffset((i*2*bj_PI/numberOfTests).asAngleRadians(), radius)
		vec2 testPoint = pos + direction
		if testPoint.isTerrainWalkable()
			addedVecs += direction
	return addedVecs.setLength(1.) * (-1.)
	
public function getBounceVec(vec2 vel2, vec2 nor2) returns vec2
		vec3 vel3 = vel2.toVec3()
		vec3 nor3 = nor2.toVec3()
		vec3 pv3 = vel3.project(nor3)
		vec2 pv2 = pv3.toVec2()
		pv2 *= (-1.9)
		return pv2

		
boolean first = true
init
	EventListener.add(EVENT_PLAYER_END_CINEMATIC) ->
		if first
			for i = 0 to 20
				let child = new Child(vec3(-800, 3500, 20), Player(0), 'hfoo')
				child.setVel(vec3(-10. -i, -10. + i, 2))
				doAfter(15) ->
					child.terminate()
			// first = false
		else
		